---
title: 信友队 2023.9.29 模拟赛 做题记录
date: 2023-09-29 18:45:50
categories: 做题记录
---

0 + 0 + 0 + 0．

二维数点都能启动失败的．/cf

<!-- more -->

## A. 商店

考虑在时刻 $t$，若先去 $i$ 再去 $j$ 比先去 $j$ 再去 $i$ 更优，那么我们有

$$
\begin{alignedat}{}
& & t + ta_i + b_i + 1 + (t + ta_i + b_i + 1)a_j + b_j &\le t + ta_j + b_j + 1 + (t + ta_j + b_j + 1)a_i + b_i \\
& \Rightarrow & b_i + b_ia_j + a_j + b_j &\le b_j + b_ja_i + a_i + b_i
\end{alignedat}
$$

很神奇啊，$t$ 没了，也就是说对于选取的一个集合，我们去买东西的顺序其实是一定的．

将序列按照上述方式排序后，问题弱化为选出子序列，最大化子序列长度，容易设计一个 DP 来解决．设 $f_{i, j}$ 表示考虑了前 $i$ 个商店，当前时刻为 $j$ 的最长子序列长度，转移是简单的．

这 DP 第二维有 $10^9$，显然寄了，但是注意到 $a_i \not= 0$ 时的答案并不大，大概是 $\log$ 级别的（这是因为每选一个 $a_i \not= 0$ 的商店时，时刻至少翻倍），于是考虑只 DP $a_i \not= 0$ 的部分，剩下的商店显然可以贪心拼接，然后将 DP 的值域和定义域换一下，设 $f_{i, j}$ 表示考虑前 $i$ 个商店，子序列长度为 $j$ 的最小时刻，就可以解决了．

时间复杂度 $O(n \log n)$．

## B. 下午茶

由于 $p$ 是奇数，我们建出 $x \to 2x \bmod n$ 的边，容易证明这张图由若干个环构成．

又由于 $(2^y + 1, p) = 1$，也就是说不存在 $k$ 使得 $2^k \equiv -1 \pmod p$，这证明 $x$ 和 $-x$ 一定在不同的环中．且 $x$ 和 $-x$ 所在的环中的元素仅相差一个符号，也就是说可以将其一一对应，我们的目标是用最小的代价使得对应元素相等．

上文中可以看出，环的总数为偶数，所以我们只需要解决有两个环的情况就解决了问题．

考虑将环对齐后对位相减，目标变成调整成 $0$，这不是我们 [糖果传递](https://www.luogu.com.cn/problem/P2512) 吗！然后就做完了．

## C. 逆向惯性思维

下辈子注意别把式子抄掉几项．

容易发现题目让我们求的就是

$$
\sum_{S \subseteq U} (\max_{i \in S} x_i - \min_{i \in S} x_i) \times (\max_{i \in S} y_i - \min_{i \in S} y_i)
$$

拆！

$$
\sum_{S \subseteq U} \max_{i \in S} x_i \times \max_{i \in S} y_i - \sum_{S \subseteq U} \max_{i \in S} x_i \times \min_{i \in S} y_i - \sum_{S \subseteq U} \min_{i \in S} x_i \times \max_{i \in S} y_i + \sum_{S \subseteq U} \min_{i \in S} x_i \times \min_{i \in S} y_i
$$

显然四个 $\sum$ 做法相同，我们只需要解决一个就行．以第一个为例．

考虑扫 $x$，设当前的点为 $(x_i, y_i)$，我们将贡献分成两个部分：$\max y$ 由 $i$ 取到的和 $\max y$ 由其他点取到的．第一部分是容易计算的，设在 $i$ 左下方的点的个数为 $\mathrm{ct}$，那么这一部分贡献就是 $x_iy_i(2^{\mathrm{ct}} - 1)$．

考虑计算第二部分，我们可以枚举在 $i$ 左上方的一个点，显然在这个点下方的所有点都是可以随便选的，反演一下，每个点会对 $y$ 坐标大于自己的点造成一次 $\times 2$ 的贡献．但是这个做法无法处理存在 $y$ 坐标相同的点的情况．考虑 $y$ 坐标相同的点的贡献系数长什么样，发现状若一个等比求和，那么再多支持一个单点加就能做了．

## D. 模糊的字符串

鉴定为烂．

由 [经典套路](/posts/2023-03-31-sim-reform-solution) 可得，直接使用主席树维护 hash 就能算 LCP．

考虑如何比字典序，若有一个串 LCP 后面一个字符此前没有出现过，那么肯定是这个串的字典序大．若此前都出现过，我们需要比较字符在子串中第一次出现位置，这个可以轻易用二分解决．
